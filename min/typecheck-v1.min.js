"use strict";const typechecked=function(){let d={};const y=async function(){}.constructor;const m=function*(){}.constructor;const w=async function*(){}.constructor;class g{#name;#splitUnionTypes;#rawType;#generics;#tupleElements;constructor(e){Object.seal(this);this.#name=e.trim();if(this.#name===""){throw SyntaxError("Expected type name")}const t=this.#name.match(/[^a-zA-Z\u00aa-\uffdc0-9_$\.\s<>\[\],|*]/)?.[0];if(t!==undefined){throw SyntaxError(`Invalid character '${t} in type declaration '${this}`)}if(/(?<!function|async)\*/.test(this.#name)){throw SyntaxError(`Unexpected token '*' in type declaration '${this}'`)}this.#splitUnionTypes=this.#getSplitUnionTypes();this.#tupleElements=this.#getTupleElements();this.#rawType=this.#getRawType();this.#generics=this.#getGenerics()}toString(){return this.#name}#splitOutsideGenericsAndTuples(t,n){const r=[""];let s=0;let i=0;for(let e=0;e<t.length;e++){switch(t[e]){case"<":s++;break;case">":s--;if(s<0){throw SyntaxError(`Unexpected token '>' in type declaration '${this}'`)}break;case"[":i++;break;case"]":i--;if(i<0){throw SyntaxError(`Unexpected token ']' in type declaration '${this}'`)}break;case n:if(s===0&&i===0){r.push("");continue}break}r[r.length-1]+=t[e]}if(s>0){throw SyntaxError(`Unclosed generic in type declaration '${this}'`)}if(i>0){throw SyntaxError(`Unclosed tuple in type declaration '${this}'`)}return r}#getSplitUnionTypes(){let e=0;let t=0;const n=this.#splitOutsideGenericsAndTuples(this.#name,"|");if(n[0]===""){throw SyntaxError(`Expected type name before '|' token in type declaration '${this}'`)}else if(n.at(-1)===""){throw SyntaxError(`Expected type name after '|' token in type declaration '${this}'`)}else if(n.some(e=>e==="")){throw SyntaxError(`Unexpected token '|' in type declaration '${this}'`)}if(n.length===1){return this}return n.map(e=>new g(e))}#getTupleElements(){if(this.#splitUnionTypes.length>1){return null}const e=this.#name.match(/^([^\[]*)\[(.*)\]([^\]]*)$/);if(e===null){return null}else if(e[1]!==""){if(e[1].trim().endsWith("<")){return null}else{throw SyntaxError(`Garbage '${e[1]}' before tuple in type declaration '${this}' (for generics, use the syntax 'ContainerType<Type>')`)}}else if(e[3]!==""){throw SyntaxError(`Unexpected token '${e[3]}' in type declaration '${this}'`)}const t=e[2];const n=this.#splitOutsideGenericsAndTuples(t,",");if(n[0]===""){if(n.length===1){return[]}else{throw SyntaxError(`Expected type name before ',' token in generic in type declaration '${this}'`)}}else if(n.at(-1)===""){throw SyntaxError(`Expected type name after ',' token in generic in type declaration '${this}'`)}else if(n.some(e=>e==="")){throw SyntaxError(`Unexpected token ',' in type declaration '${this}'`)}return n.map(e=>new g(e))}#getRawType(){if(this.#splitUnionTypes.length>1){return null}if(this.#tupleElements!==null){return"Array"}const e=this.#name.replace(/<.+$/s,"").trim();const t=e.match(/[^a-zA-Z\u00aa-\uffdc0-9_$\.\s*]/)?.[0];if(t!==undefined){throw SyntaxError(`Invalid character '${t} in type declaration '${this}`)}if(e===""){throw SyntaxError(`Missing type name before generic in type declaration '${this}'`)}else if(/\s/.test(e)){throw SyntaxError(`Unexpected token '${e.split(/\s+/)[1]}' in type declaration '${this}'`)}else if(/^[0-9]/.test(e)){throw SyntaxError(`Type names can't start with numbers, got '${e}'`)}return e}#getGenerics(){if(this.#splitUnionTypes.length>1||this.#tupleElements!==null){return null}const e=this.#name.match(/^[^<]+<(.*)>([^>]*)$/);if(e===null){return null}const t=e[1];if(e[2]!==""){throw SyntaxError(`Unexpected token '${e[2]}' in type declaration '${this}'`)}else if(t===""){throw SyntaxError(`Empty generic in type declaration '${this}'`)}const n=this.#splitOutsideGenericsAndTuples(t,",");if(n[0]===""){throw SyntaxError(`Expected type name before ',' token in generic in type declaration '${this}'`)}else if(n.at(-1)===""){throw SyntaxError(`Expected type name after ',' token in generic in type declaration '${this}'`)}else if(n.some(e=>e==="")){throw SyntaxError(`Unexpected token ',' in type declaration '${this}'`)}const r=["Array","Set","Map"];if(!r.includes(this.#rawType)){throw TypeError(`Generics are only supported on ${r}, not on '${this.#rawType}'`)}switch(n.length){case 1:if(this.#rawType==="Map"){throw TypeError(`Too few arguments for ${this.#rawType} generic in type declaration '${this}'`)}break;case 2:if(this.#rawType==="Map"){break}default:throw TypeError(`Too many arguments for ${this.#rawType} generic in type declaration '${this}'`)}return n.map(e=>new g(e))}isinstance(n){switch(this.#rawType){case null:return this.#splitUnionTypes.some(e=>e.isinstance(n));case"var":return true;case"null":return n===null;case"undefined":case"void":return n===undefined;case"NaN":return typeof n==="number"&&isNaN(n);case"function":return n instanceof Function&&!n.toString().startsWith("class");case"function*":return n instanceof m&&!n.toString().startsWith("class");case"async":return n instanceof y&&!n.toString().startsWith("class");case"async*":return n instanceof w&&!n.toString().startsWith("class");case"class":return n instanceof Function&&n.hasOwnProperty("prototype")&&!(n instanceof m||n instanceof w);default:const r=this.#rawType.split(".");let t=globalThis[r[0]]??d[r[0]];for(let e of r.slice(1)){t=t?.[e]}if(t===undefined){throw ReferenceError(`'${this.#rawType}' in type declaration is not defined`)}else if(!s.isinstance(t)){throw TypeError(`'${this.#rawType}' in type declaration does not name a type`)}if(!b.isinstance(n,t)){return false}if(this.#tupleElements!==null){return n.length===this.#tupleElements.length&&this.#tupleElements.every((e,t)=>e.isinstance(n[t]))}else if(this.#generics?.length===2){for(let e of n){if(!this.#generics[0].isinstance(e[0])||!this.#generics[1].isinstance(e[1])){return false}}}else if(this.#generics?.length===1){for(let e of n){if(!this.#generics[0].isinstance(e)){return false}}}return true}}}const s=new g("class");class ${name;type=null;parent;children=[];isOptional=false;destructuredType=null;isRestParameter=false;constructor(e,t=null){Object.seal(this);this.name=e;this.parent=t}}class k{name;parameters=[];returnType=null;isArrowFunction;constructor(e,s){Object.seal(this);this.name=e;const r=/^\s*\/\*:(.+?)\*\//is;let i=0;let a=false;let c=null;let o=[];const l=(e=true,t=true)=>{let n;while(n=s.slice(i).match(e?/^\s*(\/\*:?|\/\/)/:/^\s*(\/\*[^:]|\/\/)/)){if(n[1]==="/*:"&&t){const r=s.slice(i,s.indexOf("*/",i+2)+2).trim();throw SyntaxError(`Unexpected type declaration '${r}'`)}else if(n[1]==="//"){i=s.indexOf("\n",i)}else{i=s.indexOf("*/",i+2)+2}e=true;t=true}};const f=()=>{const e=s[i];if(!"\"'`".includes(e)){return}i++;while(s[i]!==e){if(s[i]==="\\"){i++}i++}i++};let t="";let n=0;while(n>0||/^\s*([a-z_$]|(\/[\/\*]|\[))/i.test(s.slice(i))){if(s.slice(i).trim()[0]==="["){n++;i++}else if(n>0){f();switch(s[i]){case"[":n++;break;case"]":n--;break}i++}else{i+=s.slice(i).search(/\S/);if(/^[a-z_$]/i.test(s.slice(i))){const h=i;i+=s.slice(i).search(/[^a-z0-9_$\*]/i);t=s.slice(h,i)}}l()}i+=s.slice(i).search(/\S/);if(s[i]==="("){i++}else if(s.substr(i,2)==="=>"){this.parameters=[new $(t)];this.isArrowFunction=true;return}else{throw SyntaxError(`Error when parsing typechecked function ${this.name}: Unexpected character '${s[i]}' when parsing type declaration`)}while(a||!/^\s*\)/.test(s.slice(i))){l(!a);let t;let n=false;if(a){const m=c.children.map(e=>e.name).join(", ");if(c.destructuredType===Array){c.name=`[${m}]`}else{c.name=`{${m}}`}}else{let e;while(e=s.slice(i).match(/^\s*(\.\.\.)?\s*([\[\{])/)){c=new $("",c);i+=e[0].length;switch(e[2]){case"[":c.destructuredType=Array;break;case"{":c.destructuredType=Object;break}if(e[1]!==undefined){c.isRestParameter=true}l()}const w=s.slice(i).match(/^\s*(\.\.\.)?\s*([a-z_$][a-z0-9_$]*)/i);if(w[2]!==""&&o.includes(w[2])){throw SyntaxError(`Error when parsing typechecked function ${this.name}: Duplicate parameter name '${w[2]}' in typechecked function`)}t=w[2];i+=w[0].length;if(w[1]!==undefined){n=true}}l(false);const p=s.slice(i).match(r);const d=a?c:new $(t,c);d.isRestParameter||=n;if(p!==null){if(p[1].trim()==="void"){throw SyntaxError(`Error when parsing typechecked function ${this.name}: void can only be used as a return type`)}d.type=new g(p[1])}if(a){c=c.parent}l(true,false);d.isOptional=/^\s*=/.test(s.slice(i));if(d.isOptional){let e=0;let t=0;let n=0;i=s.indexOf("=",i);l();while(e>0||t>0||n>0||!/^\s*[,)]/.test(s.slice(i))){switch(s[i]){case'"':case"'":case"`":f();i--;break;case"[":e++;break;case"]":e--;break;case"{":t++;break;case"}":t--;break;case"(":n++;break;case")":n--;break}if(e<0||t<0){break}i++;l();if(i>=s.length){throw SyntaxError(`Error when parsing typechecked function ${this.name}: Unexpected end of file when typechecking function`)}}}else if(c?.destructuredType!==Object){if((c?.children??this.parameters).some(e=>e.isOptional)){throw SyntaxError(`Error when parsing typechecked function ${this.name}: Parameter '${d.name}' is non-optional but is placed after an optional parameter`)}}if(c===null){this.parameters.push(d)}else{c.children.push(d)}const y=s.slice(i).match(/^\s*([\]\},])/);if(y!==null){a=y[1]!==",";i+=y[0].length}else{a=false}if(i>=s.length){throw SyntaxError(`Error when parsing typechecked function ${this.name}: Unexpected end of file when typechecking function`)}}i=s.indexOf(")",i)+1;l(false);const u=s.slice(i).match(r);if(u!==null){this.returnType=new g(u[1])}l(true,false);this.isArrowFunction=/^\s*=>/.test(s.slice(i))}checkArgs(t,n=this.parameters,r=this.name){const e=n.filter(e=>!e.isOptional&&!e.isRestParameter).length;const s=this.isArrowFunction||n.at(-1)?.isRestParameter?Infinity:n.length;if(t.length<e){throw TypeError(`${t.length} arguments passed to ${r}, but at least ${e} were expected.`)}if(t.length>s){throw TypeError(`${t.length} arguments passed to ${r}, but at most ${s} were expected.`)}for(let e=0;e<n.length&&(e<t.length||n[e].isRestParameter);e++){const i=n[e].isRestParameter?t.slice(e):t[e];if(!(n[e].type?.isinstance(i)??true)){throw TypeError(`Expected parameter '${n[e].name}' of ${r} to be of type '${n[e].type}', got '${E(i)}'`)}if(n[e].destructuredType===Array){this.checkArgs(i,n[e].children,`destructured parameter '${n[e].name}' of ${r}`)}else if(n[e].destructuredType===Object){this.checkNamedArgs(i,n[e].children,`destructured parameter '${n[e].name}' of ${r}`)}}}checkNamedArgs(t,n,r){for(let e of n){if(!(e.name in Object(t))){if(e.isOptional){continue}else{throw TypeError(`Parameter passed as ${r} does not have a property named ${e.name}`)}}const s=t[e.name];if(!(e.type?.isinstance(s)??true)){throw TypeError(`Expected parameter '${e.name}' of ${r} to be of type '${e.type}', got '${E(s)}'`)}if(e.destructuredType===Array){this.checkArgs(s,e.children,`destructured parameter '${e.name}' of ${r}`)}else if(e.destructuredType===Object){this.checkNamedArgs(s,e.children,`destructured parameter '${e.name}' of ${r}`)}}}checkReturnValue(e){if(this.returnType!==null&&!this.returnType.isinstance(e)){throw TypeError(`Expected return value of ${this.name} to be of type '${this.returnType}', got '${E(e)}'`)}}}function E(r){if(r===null){return"null"}else if(typeof r==="number"&&isNaN(r)){return"NaN"}else if(r instanceof Array||r instanceof Set){let t=new Set;for(let e of r){if(e===null){t.add("null")}else if(typeof e==="number"&&isNaN(e)){t.add("NaN")}else{t.add(String(e?.constructor.name))}}if(t.size>0){return`${r.constructor.name}<${[...t].join(" | ")}>`}}else if(r instanceof Map){let t=new Set;let n=new Set;for(let e of r){if(e[0]===null){t.add("null")}else if(typeof e[0]==="number"&&isNaN(e[0])){containedTypes.add("NaN")}else{t.add(String(e[0]?.constructor.name))}if(e[1]===null){n.add("null")}else if(typeof e[1]==="number"&&isNaN(e[1])){containedTypes.add("NaN")}else{n.add(String(e[1]?.constructor.name))}}if(t.size>0){return`${r.constructor.name}<${[...t].join(" | ")}, ${[...n].join(" | ")}>`}}return String(r?.constructor.name)}function b(r,{name:s=r.name,kind:i=r.toString().startsWith("class")?"class":"function"}={}){if(typeof r!=="function"){throw TypeError(`Expected parameter 'undecorated' of function 'typechecked' to be of type 'function | class', got '${E(r)}'`)}if(typeof s!=="string"){throw TypeError(`Expected parameter 'name' of function 'typechecked' to be of type 'String', got '${E(type)}'`)}if(typeof i!=="string"){throw TypeError(`Expected parameter 'kind' of function 'typechecked' to be of type 'String', got '${E(i)}'`)}const a=s!==""?`'${s}'`:"<anonymous>";const c=s.split(".").at(-1);switch(i){case"class":if(s!==""&&!s.includes(".")){if(s in d||s in globalThis){throw ReferenceError(`Redefinition of class ${a} (typecheck.js doesn't support multiple typechecked classes with the same name, not even in different modules)`)}d[s]=r}const o=[...Object.entries(Object.getOwnPropertyDescriptors(r)).map(([e,t])=>{t.static=true;t.name=e;return t}),...Object.entries(Object.getOwnPropertyDescriptors(r.prototype)).map(([e,t])=>{t.static=false;t.name=e;return t})];for(let t of o){if(t.name==="constructor"){continue}if(t.writable===false){if(t.value instanceof Function||t.get instanceof Function||t.set instanceof Function){console.warn(s+"."+t.name+" is not writable and can't be typechecked.")}continue}const u=t.static?r:r.prototype;if(t.value instanceof Function){u[t.name]=b(t.value,{kind:b.isinstance(t.value,"function")?"method":"class",name:s+"."+t.name})}else if(t.get instanceof Function||t.set instanceof Function){let e={};if(t.get instanceof Function){e.get=b(t.get,{kind:"getter",name:t.name,static:t.static})}if(t.set instanceof Function){e.set=b(t.set,{kind:"setter",name:t.name,static:t.static})}Object.defineProperty(u,t.name,e)}}const l=r.toString();let e=0;let t=0;for(let e=0;e<l.length;e++){if(l.substr(e,2)==="//"){e=l.indexOf("\n",e)}else if(l.substr(e,2)==="/*"){e=l.indexOf("*/",e+2)+1}else if(l[e]==='"'||l[e]==="'"||l[e]==="`"){const h=l[e];e++;while(l[e]!==h){if(l[e]==="\\"){e++}e++}}else if(l[e]==="{"){t++}else if(l[e]==="}"){t--}else if(t===1&&l.slice(e).startsWith("constructor")){const p=new k(`${a} constructor`,l.slice(e));if(p.returnType!==null){throw SyntaxError("Constructors can't have return types")}return{[c]:class extends r{constructor(...e){p.checkArgs(e);super(...e)}}}[c]}}return r;case"function":case"method":case"getter":case"setter":const f=new k(a,r.toString());if(i==="setter"&&f.returnType!==null){throw SyntaxError("Setters can't have return types")}let n;if(r instanceof y){n=async function(...e){f.checkArgs(e);const t=await(f.isArrowFunction?r(...e):r.call(this,...e));f.checkReturnValue(t);return t}}else if(r instanceof m){n=function*(...e){f.checkArgs(e);const t=r.call(this,...e);for(let e=t.next();!e.done;e=t.next()){f.checkReturnValue(e.value);yield e}}}else if(r instanceof w){n=async function*(...e){f.checkArgs(e);const t=r.call(this,...e);for(let e=await t.next();!e.done;e=await t.next()){f.checkReturnValue(e.value);yield e}}}else{n=function(...e){f.checkArgs(e);const t=f.isArrowFunction?r(...e):r.call(this,...e);if(i==="setter"){if(t!==undefined){throw TypeError("Setters should not return anything")}}else{f.checkReturnValue(t)}return t}}Object.defineProperty(n,"name",{value:c,writable:false});return n;default:throw TypeError("typechecked is only allowed on classes, functions, methods, getters or setters, got "+context.kind)}}b.isinstance=function(e,t){if(t===null){return e===null}else if(t===undefined){return e===undefined}else if(s.isinstance(t)){if(e===null||e===undefined){return false}else if(t===Number){return typeof e==="number"&&!isNaN(e)}else if(t===String){return typeof e==="string"}else if(t===Boolean){return typeof e==="boolean"}else if(t===Symbol){return typeof e==="symbol"}else if(t===BigInt){return typeof e==="bigint"}else{return Object(e)instanceof t}}else if(typeof t==="string"){return new g(t).isinstance(e)}else{throw TypeError(`Expected parameter 'type' of function 'typechecked.isinstance' to be of type 'String | class | null | undefined', got '${E(t)}'`)}};b.add=b(function(...t/*: Array<class> */){for(let e of t){if(e.name===""){throw ReferenceError("Cannot call typechecked.add on anonymous classes.")}const n=e.name;if(n in d||n in globalThis){if(d[n]===e){continue}else if(e.prototype instanceof d[n]){throw ReferenceError(`Cannot call typechecked.add on class '${n}': class is already known by typechecked. You don't need to call typechecked.add on classes that are themselves typechecked.`)}else if(globalThis[n]===e){throw ReferenceError(`Cannot call typechecked.add on class '${n}': class is already known by typechecked. You don't need to call typechecked.add on classes that are members of globalThis.`)}else{throw ReferenceError(`Redefinition of class '${n}' (typecheck.js doesn't support multiple typechecked classes with the same name, not even in different modules)`)}}d[n]=e}},{name:"typechecked.add"});return Object.freeze(b)}();if(typeof window==="undefined"){module.exports=typechecked}if(0)typeof await/2;//2;export default typechecked;