"use strict";const typechecked=function(){let y={};const d=async function(){}.constructor;const m=function*(){}.constructor;const g=async function*(){}.constructor;class w{name;splitUnionTypes=[""];#genericTypes;constructor(e){Object.seal(this);this.name=e.trim();if(this.name===""){throw SyntaxError("Expected type name")}let t=[""];let n=[""];let r=0;let s=false;for(let e=0;e<this.name.length;e++){const i=this.name.slice(e).match(/^.[a-z0-9_$]*/is);const a=i[0];if(/\s/.test(this.name[e])){if(t.at(-1)!==""){s=true}}else if(r>0||this.name[e]==="<"||this.name[e]===">"){if(this.name[e]===">"){r--;if(r<0){throw SyntaxError(`Unexpected token '>' in type declaration '${this}'`)}else if(r===0&&!n.some(e=>e!=="")){throw SyntaxError(`Empty generic in type declaration '${this}'`)}}if(r>0){if(this.name[e]===","){n.push("")}else{n[n.length-1]+=this.name[e]}}if(this.name[e]==="<"){if(t.at(-1)===""){throw SyntaxError(`Expected type name before generic: '${this}'`)}if(r===0&&n.some(e=>e!=="")){throw SyntaxError(`Unexpected token '<' in type declaration '${this}'`)}r++}}else if(this.name[e]==="|"){if(t.at(-1)===""){throw SyntaxError(`Unexpected token '|' in type declaration '${this}'`)}t.push("");n=[""];s=false}else if(n.some(e=>e!=="")){throw SyntaxError(`Unexpected token '${a}' in type declaration '${this}'`)}else if(/[0-9]/.test(this.name[e])){if(s){throw SyntaxError(`Unexpected token '${a}' in type declaration '${this}'`)}if(t.at(-1)===""){throw SyntaxError(`Type names can't start with numbers, got '${this}'`)}t[t.length-1]+=this.name[e]}else if(/[a-z_$\.]/i.test(this.name[e])){if(s){throw SyntaxError(`Unexpected token '${a}' in type declaration '${this}'`)}t[t.length-1]+=this.name[e]}else if(this.name[e]==="*"){if(t.at(-1)==="function"||t.at(-1)==="async"){t[t.length-1]+="*"}else{throw SyntaxError(`Unexpected token '*' in type declaration '${this}'`)}}else{throw SyntaxError(`Unexpected character '${this.name[e]}' in type declaration '${this}'`)}}if(r>0){throw SyntaxError(`Unclosed generic in type declaration '${this}'`)}if(t.length===1){this.splitUnionTypes=[this];n=n.map(e=>e.trim()).filter(e=>e!=="");this.#genericTypes=n.map(e=>new w(e));if(this.rawType()==="Array"||this.rawType()==="Set"){if(n.length>1){let e=`${this.rawType()} generics can only have one argument, got '${n.join(", ")}'`;if(!n.some(e=>e.includes("|"))){e+=`. Did you mean '${this.rawType()}<${n.join(" | ")}>'?`}throw TypeError(e)}}else if(this.rawType()==="Map"){if(n.length!==2&&n.length!==0){throw TypeError(`${this.rawType()} generics must have exactly two arguments, got '${n.join(", ")}'`)}}else if(n.length>0){throw TypeError(`Generics are not supported on ${this.rawType()}`)}}else{this.splitUnionTypes=t.map(e=>new w(e));this.#genericTypes=[]}}toString(){return this.name}genericKey(){if(this.#genericTypes.length>1){return this.#genericTypes[0]}return null}genericValue(){return this.#genericTypes[1]??this.#genericTypes[0]??null}rawType(){if(this.splitUnionTypes.length>1){return null}return this.name.replace(/<.+$/s,"")}isinstance(n){switch(this.rawType()){case null:return this.splitUnionTypes.some(e=>e.isinstance(n));case"var":return true;case"null":return n===null;case"undefined":case"void":return n===undefined;case"function":return n instanceof Function&&!n.toString().startsWith("class");case"function*":return n instanceof m&&!n.toString().startsWith("class");case"async":return n instanceof d&&!n.toString().startsWith("class");case"async*":return n instanceof g&&!n.toString().startsWith("class");case"class":return n instanceof Function&&n.hasOwnProperty("prototype")&&!(n instanceof m||n instanceof g);default:const r=this.rawType().split(".");let t=globalThis[r[0]]??y[r[0]];for(let e of r.slice(1)){t=t[e]}if(t===undefined){throw ReferenceError(`'${this.rawType()}' in type declaration is not defined`)}else if(!s.isinstance(t)){throw TypeError(`'${this.rawType()}' in type declaration does not name a type`)}if(!b.isinstance(n,t)){return false}if(this.genericKey()!==null){for(let e of n){if(!this.genericKey().isinstance(e[0])||!this.genericValue().isinstance(e[1])){return false}}}else if(this.genericValue()!==null){for(let e of n){if(!this.genericValue().isinstance(e)){return false}}}return true}}}const s=new w("class");class ${name;type=null;parent;children=[];isOptional=false;destructuredType=null;isRestParameter=false;constructor(e,t=null){Object.seal(this);this.name=e;this.parent=t}}class x{name;parameters=[];returnType=null;isArrowFunction;constructor(e,s){Object.seal(this);this.name=e;const r=/^\s*\/\*:(.+?)\*\//is;let i=0;let a=false;let c=null;let o=[];const l=(e=true,t=true)=>{let n;while(n=s.slice(i).match(e?/^\s*(\/\*:?|\/\/)/:/^\s*(\/\*[^:]|\/\/)/)){if(n[1]==="/*:"&&t){const r=s.slice(i,s.indexOf("*/",i+2)+2).trim();throw SyntaxError(`Unexpected type declaration '${r}'`)}else if(n[1]==="//"){i=s.indexOf("\n",i)}else{i=s.indexOf("*/",i+2)+2}e=true;t=true}};const f=()=>{const e=s[i];if(!"\"'`".includes(e)){return}i++;while(s[i]!==e){if(s[i]==="\\"){i++}i++}i++};try{let e="";let t=0;while(t>0||/^\s*([a-z_$]|(\/[\/\*]|\[))/i.test(s.slice(i))){if(s.slice(i).trim()[0]==="["){t++;i++}else if(t>0){f();switch(s[i]){case"[":t++;break;case"]":t--;break}i++}else{i+=s.slice(i).search(/\S/);if(/^[a-z_$]/i.test(s.slice(i))){const u=i;i+=s.slice(i).search(/[^a-z0-9_$\*]/i);e=s.slice(u,i)}}l()}i+=s.slice(i).search(/\S/);if(s[i]==="("){i++}else if(s.substr(i,2)==="=>"){this.parameters=[new $(e)];this.isArrowFunction=true;return}else{throw SyntaxError(`Unexpected character '${s[i]}' when parsing type declaration`)}while(a||!/^\s*\)/.test(s.slice(i))){l(!a);let t;let n=false;if(a){const d=c.children.map(e=>e.name).join(", ");if(c.destructuredType===Array){c.name=`[${d}]`}else{c.name=`{${d}}`}}else{let e;while(e=s.slice(i).match(/^\s*(\.\.\.)?\s*([\[\{])/)){c=new $("",c);i+=e[0].length;switch(e[2]){case"[":c.destructuredType=Array;break;case"{":c.destructuredType=Object;break}if(e[1]!==undefined){c.isRestParameter=true}l()}const m=s.slice(i).match(/^\s*(\.\.\.)?\s*([a-z_$][a-z0-9_$]*)/i);if(m[2]!==""&&o.includes(m[2])){throw SyntaxError(`Duplicate parameter name '${m[2]}' in typechecked function`)}t=m[2];i+=m[0].length;if(m[1]!==undefined){n=true}}l(false);const h=s.slice(i).match(r);const p=a?c:new $(t,c);p.isRestParameter||=n;if(h!==null){p.type=new w(h[1])}if(a){c=c.parent}l(true,false);p.isOptional=/^\s*=/.test(s.slice(i));if(p.isOptional){let e=0;let t=0;let n=0;i=s.indexOf("=",i);l();while(e>0||t>0||n>0||!/^\s*[,)]/.test(s.slice(i))){switch(s[i]){case'"':case"'":case"`":f();i--;break;case"[":e++;break;case"]":e--;break;case"{":t++;break;case"}":t--;break;case"(":n++;break;case")":n--;break}if(e<0||t<0){break}i++;l();if(i>=s.length){throw SyntaxError("Unexpected end of file when typechecking function")}}}else if(c?.destructuredType!==Object){if((c?.children??this.parameters).some(e=>e.isOptional)){throw SyntaxError(`Parameter '${p.name}' is non-optional but is placed after an optional parameter`)}}if(c===null){this.parameters.push(p)}else{c.children.push(p)}const y=s.slice(i).match(/^\s*([\]\},])/);if(y!==null){a=y[1]!==",";i+=y[0].length}else{a=false}if(i>=s.length){throw SyntaxError("Unexpected end of file when typechecking function")}}i=s.indexOf(")",i)+1;l(false);const n=s.slice(i).match(r);if(n!==null){this.returnType=new w(n[1])}l(true,false)}catch(e){throw e.constructor(`Error when parsing typechecked function ${this.name}: ${e.message}`)}this.isArrowFunction=/^\s*=>/.test(s.slice(i))}checkArgs(t,n=this.parameters,r=this.name){const e=n.filter(e=>!e.isOptional&&!e.isRestParameter).length;const s=n.at(-1)?.isRestParameter?Infinity:n.length;if(t.length<e){throw TypeError(`${t.length} arguments passed to ${r}, but at least ${e} were expected.`)}if(t.length>s){throw TypeError(`${t.length} arguments passed to ${r}, but at most ${s} were expected.`)}for(let e=0;e<n.length&&(e<t.length||n[e].isRestParameter);e++){const i=n[e].isRestParameter?t.slice(e):t[e];if(!(n[e].type?.isinstance(i)??true)){throw TypeError(`Expected parameter '${n[e].name}' of ${r} to be of type '${n[e].type}', got '${T(i)}'`)}if(n[e].destructuredType===Array){this.checkArgs(i,n[e].children,`destructured parameter '${n[e].name}' of ${r}`)}else if(n[e].destructuredType===Object){this.checkNamedArgs(i,n[e].children,`destructured parameter '${n[e].name}' of ${r}`)}}}checkNamedArgs(t,n,r){for(let e of n){if(!(e.name in Object(t))){if(e.isOptional){continue}else{throw TypeError(`Parameter passed as ${r} does not have a property named ${e.name}`)}}const s=t[e.name];if(!(e.type?.isinstance(s)??true)){throw TypeError(`Expected parameter '${e.name}' of ${r} to be of type '${e.type}', got '${T(s)}'`)}if(e.destructuredType===Array){this.checkArgs(s,e.children,`destructured parameter '${e.name}' of ${r}`)}else if(e.destructuredType===Object){this.checkNamedArgs(s,e.children,`destructured parameter '${e.name}' of ${r}`)}}}checkReturnValue(e){if(this.returnType!==null&&!this.returnType.isinstance(e)){throw TypeError(`Expected return value of ${this.name} to be of type '${this.returnType}', got '${T(e)}'`)}}}function T(r){if(r===null){return"null"}else if(r instanceof Array||r instanceof Set){let t=new Set;for(let e of r){if(e===null){t.add("null")}else{t.add(String(e?.constructor.name))}}if(t.size>0){return`${r.constructor.name}<${[...t].join(" | ")}>`}}else if(r instanceof Map){let t=new Set;let n=new Set;for(let e of r){if(e[0]===null){t.add("null")}else{t.add(String(e[0]?.constructor.name))}if(e[1]===null){n.add("null")}else{n.add(String(e[1]?.constructor.name))}}if(t.size>0){return`${r.constructor.name}<${[...t].join(" | ")}, ${[...n].join(" | ")}>`}}return String(r?.constructor.name)}function b(r,{name:s=r.name,kind:i=r.toString().startsWith("class")?"class":"function"}={}){if(typeof r!=="function"){throw TypeError(`Expected parameter 'undecorated' of function 'typechecked' to be of type 'function | class', got '${T(r)}'`)}if(typeof s!=="string"){throw TypeError(`Expected parameter 'name' of function 'typechecked' to be of type 'String', got '${T(type)}'`)}if(typeof i!=="string"){throw TypeError(`Expected parameter 'kind' of function 'typechecked' to be of type 'String', got '${T(i)}'`)}const a=s!==""?`'${s}'`:"<anonymous>";const c=s.split(".").at(-1);switch(i){case"class":if(s!==""&&!s.includes(".")){if(s in y||s in globalThis){throw ReferenceError(`Redefinition of class ${a} (typecheck.js doesn't support multiple typechecked classes with the same name, not even in different modules)`)}y[s]=r}const o=[...Object.entries(Object.getOwnPropertyDescriptors(r)).map(([e,t])=>{t.static=true;t.name=e;return t}),...Object.entries(Object.getOwnPropertyDescriptors(r.prototype)).map(([e,t])=>{t.static=false;t.name=e;return t})];for(let t of o){if(t.name==="constructor"){continue}if(t.writable===false){if(t.value instanceof Function||t.get instanceof Function||t.set instanceof Function){console.warn(s+"."+t.name+" is not writable and can't be typechecked.")}continue}const u=t.static?r:r.prototype;if(t.value instanceof Function){u[t.name]=b(t.value,{kind:b.isinstance(t.value,"function")?"method":"class",name:s+"."+t.name})}else if(t.get instanceof Function||t.set instanceof Function){let e={};if(t.get instanceof Function){e.get=b(t.get,{kind:"getter",name:t.name,static:t.static})}if(t.set instanceof Function){e.set=b(t.set,{kind:"setter",name:t.name,static:t.static})}Object.defineProperty(u,t.name,e)}}const l=r.toString();let e=0;let t=0;for(let e=0;e<l.length;e++){if(l.substr(e,2)==="//"){e=l.indexOf("\n",e)}else if(l.substr(e,2)==="/*"){e=l.indexOf("*/",e+2)+1}else if(l[e]==='"'||l[e]==="'"||l[e]==="`"){const h=l[e];e++;while(l[e]!==h){if(l[e]==="\\"){e++}e++}}else if(l[e]==="{"){t++}else if(l[e]==="}"){t--}else if(t===1&&l.slice(e).startsWith("constructor")){const p=new x(`${a} constructor`,l.slice(e));if(p.returnType!==null){throw SyntaxError("Constructors can't have return types")}return{[c]:class extends r{constructor(...e){p.checkArgs(e);super(...e)}}}[c]}}return r;case"function":case"method":case"getter":case"setter":const f=new x(a,r.toString());if(i==="setter"&&f.returnType!==null){throw SyntaxError("Setters can't have return types")}let n;if(r instanceof d){n=async function(...e){f.checkArgs(e);const t=await(f.isArrowFunction?r(...e):r.call(this,...e));f.checkReturnValue(t);return t}}else if(r instanceof m){n=function*(...e){f.checkArgs(e);const t=r.call(this,...e);for(let e=t.next();!e.done;e=t.next()){f.checkReturnValue(e.value);yield e}}}else if(r instanceof g){n=async function*(...e){f.checkArgs(e);const t=r.call(this,...e);for(let e=await t.next();!e.done;e=await t.next()){f.checkReturnValue(e.value);yield e}}}else{n=function(...e){f.checkArgs(e);const t=f.isArrowFunction?r(...e):r.call(this,...e);if(i==="setter"){if(t!==undefined){throw TypeError("Setters should not return anything")}}else{f.checkReturnValue(t)}return t}}Object.defineProperty(n,"name",{value:c,writable:false});return n;default:throw TypeError("typechecked is only allowed on classes, functions, methods, getters or setters, got "+context.kind)}}b.isinstance=function(e,t){if(t===null){return e===null}else if(t===undefined){return e===undefined}else if(s.isinstance(t)){if(e===null||e===undefined){return false}else if(t===Number){return typeof e==="number"}else if(t===String){return typeof e==="string"}else if(t===Boolean){return typeof e==="boolean"}else if(t===Symbol){return typeof e==="symbol"}else if(t===BigInt){return typeof e==="bigint"}else{return Object(e)instanceof t}}else if(typeof t==="string"){return new w(t).isinstance(e)}else{throw TypeError(`Expected parameter 'type' of function 'typechecked.isinstance' to be of type 'String | class | null | undefined', got '${T(t)}'`)}};return Object.freeze(b)}();if(typeof window==="undefined"){module.exports=typechecked}if(0)typeof await/2;//2;export default typechecked;